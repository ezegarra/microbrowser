What's wrong with Java? Oh god. Two words: Checked Exceptions. Whenever I'm hacking, tested out ideas or goofing around, I always get 500 compiler error--not warnings!--that I'm ignoring some XDoesShitException. Not only that, but half the time, the stuff they want me to catch isn't exceptional in the least! Take Integer.decode(string s). If s happens to be "cats" or something, I get a NumberFormatException. If I know it's not going to happen, I have to have a try catch block in the middle of my code anyway, just because it might happen. In C#, I can use int.parse for Java like semantics or I can use int.tryparse(string s, out int i), which'll return me a nice happy bool telling me if s was a string or not. No extra blocks, no stupid compiler errors, just a bool, which is all I wanted in the first place! Oh, and speaking of the compiler. If I have some code that isn't reachable--I decided to return early in a function while testing something or other, it whines and shuts down. No other compiler I know of complains about this sort of stuff. Gimme a warning on the lowest error level, but don't just die! Sun. Want to make a webapp? OK, first pick from the 100 different web frameworks. Next, pick one of the 5,000 app servers to run it on, most of which are non trivial to configure. To write your code you can choose from the 3 leading IDEs. Now as you're developing your app you're faced with decisions. What kind of logging do you use? Well there's at least 3 different ways to do it. What about XML parsing and writing? You spend all this time trying to figure out which API to use and then learning it. Maybe halfway through you realize you've chosen something that's obsolete. So you're frustrated. It's all because of the fact that Sun doesn't standardize anything. In a lot of ways competition is good, but in the grand scheme of things the way competition works in he Java world is broken. It takes eons for JSRs to become reality. It's probably a lack of focus - seriously how many people are going to actually be creating JavaFX apps? In the meantime Apple just says "sup, this is the way this works now oh and don't do this anymore because it'll be obsolete soon." It's a world easier. Some of the more valid criticisms are: Java is mainstream, and many Java programmers have a bad reputation Java lacks reflection The Java API is huge. It's a case of design patterns gone wild, and that philosophy has seeped its way into most of the Java frameworks out there. Java is fairly verbose -- You need the class namespace for everything - you have to use static variables/methods instead of global variables/functions. -- Things like ArrayLists/vectors are in the library but not baked into the language. -- Encapsulation is taken to an extreme. Using a private foo + getFoo() + setFoo(bar) is the same thing as using a public foo, right? If you don't want somebody to setFoo, then it makes sense, but otherwise, no. Java isn't changing very quickly, even compared to C# (which now has type inference and closures) -- Autoboxing/autounboxing came in very late. -- The foreach loop came in very late. -- Still no tuples. Of course, there are invalid criticisms, like ones about speed and claims that all Java programmers are incompetent. Criticism of static typing depends on the situation. Using Ohloh, Compare the number of lines of code for most Java projects and comparable projects written in higher level languages. The use of interfaces and static typing over latent/dynamic typing and the general attitude that more code is good (or so it seems) can be quite frustrating. Java is getting old and it's much lower level than newer languages - which is usually bad. Use it if you need speed or really well-tested, enterprise-quality frameworks. Probably the JCP. Even if good things can come out out of design-by-committee it isn't optimal (type-erased generics?) nor do things happen very quickly. Java feels old compared to C#, which started off as a Java clone. Wikipedia has a whole article on what's wrong with Java. @Nikhil Java is mainstream This is not a valid criticism. Things don't become bad just because they become mainstream. Java lacks reflection This is not true. Java was the first mainstream language to have real reflection capabilities. Java is getting old and it's much lower level than newer languages - which is usually bad. Java isn't low-level. It's statically typed. The two are not the same. I think most of the flak Java gets is because it's popular. It certainly has problems, and there are certainly better languages, but Java gets way too much heat for its problems in comparison to the praise it gets for bringing object-oriented programming and garbage collection to the masses. Steve Yegge had a good (if not very concise) essay that touched on this last year, "Code's Worst Enemy": If you begin with the assumption that you need to shrink your code base, you will eventually be forced to conclude that you cannot continue to use Java. Conversely, if you begin with the assumption that you must use Java, then you will eventually be forced to conclude that you will have millions of lines of code. I regularly see/hear negative comments about Java, but there never seems to be any specific negative point about it, at least nothing that hasn't been addressed in later versions. How many of those people actually use Java on a regular basis and know the language well enough to make justified criticism of it? Since you are saying they never mention any specific disadvantages, but simply have a "Java is bad" attitude, I suspect these people are not the right crowd to listen to when it comes to the quality of Java as a programming language and development tool. The best way to find out what is wrong with Java is to learn it and use it yourself. Only then can you make up your own opinion. Java, as every other programming language ever invented, has its advantages and disadvantages. Which of those matter to you is highly dependent on what you intend to use the language for. It's all about choosing the right tool for the right job. If you want to be a programmer, learn Java, but also learn C# and Ruby, Python, PHP or Perl. The more languages you know, the better equipped you will be to use the best language for a given task. Most of the answers here are somewhat misleading (No Reflection WTF?) and thats coming from a .NET developer, who also does some Java work. I have five main gripes with Java: Java does not have real generics Generics in Java are simply syntax sugar. When you compile, the generic information is stripped out, and the compiler automaticly boxes/unboxes the values. This means you don't get the speed advantage of avoiding casts with strong typed generics (ala C#), and you also cannot use reflection to introspect the generic type, because it is gone. Java's namespaces (err Packages) are polluted. This is mostly personal preferenced, but I find the java.lang.* namespaces to be both poorly organized, and stuffed to the gills in deprecated classes. Java does not have anonymous methods, or a function pointer equivalent (ie, delegates). While Java does have anonymous inner classes, I find anonymous methods more useful (and much more lightweight) in my day to day use. This is also why wiring up a GUI in Java is so painful. WTF is wrong with Java's Date/Time Handling? I don't need to go to into detail on this one. Sun screwed up big time here, a minor list: Java DateTime Objects are mutable (wtf? you can't pass a date to a method and trust it not to be modified, or depend on a Java Date as a hashkey.) Java has no concept of "TimeSpan" Java DateTime is an object, not a struct, so it must be allocated on the heap. Java's lack of operator overloading means you cannot compare two DateTimes with comparison operators (<=, =>, ==, != etc). Getters and Setters as methods. This is a personal preference, but I much prefer this: DateTime currentTime = DateTime.Now; Compared too:  DateTime currentTime = new DateTime().getCurrentTime();
 All that said, rest assured that I could come up with just as long of a list as to why I dislike C#. Its just that was not the question :) I wish I could embrace Java, unfortunately, it seems to consume way too much memory for the most seemingly simplest apps. It's perfectly adequate. The lack of macro language, true generics, and the foisting of OO braindamage on everyone are problems, but not the end of the world. I see two* main problems with Java: The Kingdom of Nouns syndrome Doing the simple easy thing is cluttered up with implementation details of what you'd need when you're doing the complex, carefully optimized thing To elaborate: The Kingdom of Nouns syndrome is another way of saying that Java doesn't want you to create functions as objects. It's possible, but it goes violently against the design principles of just about every library and framework you'll see. Time and time again I find myself settling on code duplication or inelegant hacks because Java doesn't like functions as objects. If Java gets closures I will be a happy person indeed. As for the second, I'll simply pose a question: Can you write a Java program to read in a file line by line and do something with each line? Off the top of your head? Without referring to documentation or other code? Without your IDE? And have it compile and run on your first try? If you can, you're a far better BufferedInputPerson than I am. This isn't so much a problem with the language as it is the standard library. Well, ignoring the exception debate. You did remember to handle exceptions, didn't you? I mean, in theory, it could be as simple as: for(String line : new FileLineReader(filename))
    doSomething(line);
 ...but that isn't really in the Java style. I mean, I love the power of the Java library, but it seems like not much effort is made to make the easy things easy. * Two technical problems that is. There are still some people around with a sour taste in their mouths from back when java was slow, garbage collection paused execution, and tool support hadn't made Java habitable yet I think Java's reputation has never fully recovered from the days when people mostly used it to put bloated applets on their web pages. It seems that people still make that connection when they hear the word 'Java'. That said, Java does have many real drawbacks and annoyances (as does any language). Most of them have been outlined above. I particularly second Patrick's comment on checked exceptions. Here is my favorite example of that: try {
    ...
    writer = new FileWriter(pathToFile);
    writer.write("Some stuff");
    writer.flush();
} catch(IOException e) {
    // OK, so an IO error could occur, log it and deal with if possible
} finally {
    // We want to close the stream regardless of if an exception occurred.
    try {
         writer.close(); // But close() throws a checked exception!
    } catch (IOException e) {
         // It does not make any sense to throw this exception, so we have to catch it
    }
}
 The only way to make this code less bloated is to have the method throw an IOException, which is essentially only passing the problem on to the caller. For the record though, I do most of my work in Java and generally like it. Java is alright, but it's not suited for web applications. The frameworks require a huge amount of configuration and setup. To quote "Agile Web Development with Ruby on Rails": Follow the conventions, and you can write a Rails application using less code than a typical Java web application uses in XML configuration. And although this is worst with web applications, you can find similar situations elsewhere in Java. There are problems with every language. If not, there would be no reason to continue to create new ones and everyone would use the last one ever invented. In my opinion, the problems with Java are not technical issues; Java is an extremely capable platform. However, as more features and frameworks are incorporated the learning curve steepens and lengthens. I have heard very successful Java developers state this as a reason they adopted Ruby on Rails. For me personally the problem with Java is it takes too long. I am not referring to execution speed but development speed. I investigated Ruby on Rails because the productivity can be nothing short of amazing. Although the productivity of Rails was apparent, I was horrified at the prospect of throwing away the entire enterprise code base. Grails to the rescue! Groovy eliminates much of the verbosity of Java while still being Java. Incorporating Groovy into a Java code base works. Grails makes starting new application development lightning quick. The foundation is built on proven Java projects while the complexity is removed, unless you need it. Use Spring and Hibernate without headaches. The plug-in architecture allows incorporating additional features as needed. Deploy anywhere you have a container. The problem with Java is lack of productivity, one solution is Grails.