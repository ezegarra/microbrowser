How to convert a Reader to InputStream and a Writer to OutputStream? stream The obvious names for these classes are ReaderInputStream and WriterOutputStream. Unfortunately these are not included in the Java library. However, google is your friend. I'm not sure that it is going to get around all text encoding problems, which are nightmarish. There is an RFE, but it's Closed, will not fix. You can't really avoid dealing with the text encoding issues, but there are existing solutions, Reader to InputStream: ReaderInputStream Writer to OutputStream: WriterOutputStream You just need to pick the encoding of your choice Are you trying to write the contents of a Reader to an OutputStream? If so, you'll have an easier time wrapping the OutputStream in an OutputStreamWriter and write the chars from the Reader to the Writer, instead of trying to convert the reader to an InputStream: final Writer writer = new BufferedWriter(new OutputStreamWriter( urlConnection.getOutputStream(), "UTF-8" ) );
int charsRead;
char[] cbuf = new char[1024];
while ((charsRead = data.read(cbuf)) != -1) {
    writer.write(cbuf, 0, charsRead);
}
writer.flush();
// don't forget to close the writer in a finally {} block
 If you are starting off with a String you can also do the following: new ByteArrayInputStream(inputString.getBytes("UTF-8"))
 commons-io 2.0 has WriterOutputStream Also note that, if you're starting off with a String, you can skip creating a StringReader and create an InputStream in one step using org.apache.commons.io.IOUtils from Commons IO like so: InputStream myInputStream = IOUtils.toInputStream(reportContents, "UTF-8");
 Of course you still need to think about the text encoding, but at least the conversion is happening in one step. You can't avoid text encoding issues, but Apache commons-io has ReaderInputStream WriterOutputStream Note these are the libraries referred to in Peter's answer of koders.com, just links to the library instead of source code. Well, a Reader deals with characters and an InputStream deals with bytes. The encoding specifies how you wish to represent your characters as bytes, so you can't really ignore the issue. As for avoiding problems, my opinion is: pick one charset (e.g. "UTF-8") and stick with it. Regarding how to actually do it, as has been pointed out, "the obvious names for these classes are ReaderInputStream and WriterOutputStream." Surprisngly, "these are not included in the Java library" even though the 'opposite' classes, InputStreamReader and OutputStreamWriter are included. So, lots of people have come up with their own implementations, including Apache Commons IO. Depending on licensing issues, you will probably be able to include the commons-io library in your project, or even copy a portion of the source code (which is downloadable here). Apache ReaderInputStream: API / source code direct link Apache WriterOutputStream: API / source code direct link As you can see, both classes' documentation states that "all charset encodings supported by the JRE are handled correctly". N.B. A comment on one of the other answers here mentions this bug. But that affects the Apache Ant ReaderInputStream class (here), not the Apache Commons IO ReaderInputStream class. A warning when using WriterOutputStream - it doesn't always handle writing binary data to a file properly/the same as a regular output stream. I had an issue with this that took me awhile to track down. If you can, I'd recommend using an output stream as your base, and if you need to write strings, use an OUtputStreamWriter wrapper around the stream to do it. It is far more reliable to convert text to bytes than the other way around, which is likely why WriterOutputStream is not a part of the standard Java library