How can an application use multiple cores or CPUs in .NET or Java? c# multithreading If you're using multiple threads, the operating system will automatically take care of using multiple cores. Related thread: How do I spawn threads on different CPU cores? The operating system takes care of multi-threading when the virtual machine is using native threads (as opposed to green-threads), and you can't specify low level details, like choosing a processor for a certain thread. It is better that way because you usually have many more threads than you have processors available, so the operating system needs to do time-slicing to give all threads a chance to run. That being said, you can set threads priorities if you have a critical task, and a threading API usually provides this possibility. See the Java API for example: http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Thread.html#setPriority(int) PS: there's something broken in the parsing engine ... I had to add the above link as plain text is there a way to choose which processor or core it is launched on? You can use the task manager to tell windows what CPU(s) your program should be allowed to run on. Normally this is only useful for troubleshooting legacy programs which have broken implementations of multi-threading. To do this, Run task manager Find your process in the Processes window. Right click and choose Set Affinity... Tick the checkboxes next to the CPU's you want to allow your application to run on. Windows will then only schedule threads from that process onto those particular CPU's If I recall correctly, windows will 'remember' these settings for subsequent times your process is run, but please don't quote me on that - run some tests yourself :-) You can also do this programatically in .NET after your program has launched using using the System.Diagnostics.Process.ProcessorAffinity property, but I don't think it will 'remember' the settings, so there will always be a short period in which your app is run on whichever CPU windows sees fit. I don't know how to do this in java sorry. Note: This applies at the entire process level. If you set affinity for CPU0 only, and then launch 50 threads, all 50 of those threads will run on CPU0, and CPU1, 2, 3, etc will sit around doing nothing. Just to reiterate the point, this is primarily useful for troubleshooting broken legacy software. If your software is not broken, you really shouldn't mess with any of these settings, and let windows decide the best CPU(s) to run your program on, so it can take the rest of the system's performance into account. As for the 'shared memory' model, it works the same, but there are more things that can go subtly wrong when your app is running on multiple CPU's as opposed to just timeslices on a single one. For an eye-opening example, read this ridiculousfish article about CPU's and Memory Barriers. It's aimed at OSX development on PowerPC, but general enough that it should apply everywhere. IMHO it's one of the top ten 'all developers should read this' articles I've read. I have used this in a couple of programs because my core 0 was kind of messed up. // Programmatically set process affinity
var process = System.Diagnostics.Process.GetCurrentProcess();

// Set Core 0
process.ProcessorAffinity = new IntPtr(0x0001);
 or // Set Core 1
process.ProcessorAffinity = new IntPtr(0x0002);
 More on this in "Process.ProcessorAffinity Property". I would have a look at the Parallel extensions to the .NET framework. It is still in CTP, however it supposed to make the best use of multi core processors. The easiest place to get started for .NET is on the parallel teams blog. As for Java I have no idea.