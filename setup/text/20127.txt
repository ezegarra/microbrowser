Virtual Machine Optimization jvm jit cil Optimising bytecode is probably an oxymoron in most cases. Unless you control the VM, you have no idea what it does to speed up code execution, if anything. The compiler would need to know the details of the VM in order to generate optimised code. Optimising bytecode is probably an oxymoron in most cases I don't think that's true. Optimizations like hoisting loop invariants and propagating constants can never hurt, even if the JVM is smart enough to do them on its own, by simple virtue of making the code do less work. I'm just gonna add two links which explain Java's bytecode pretty well and some of the various optimization of the JVM during runtime. Optimisation is what makes JVMs viable as environments for long running applications, you can bet that SUN, IBM and friends are doing their best to ensure they can optimise your bytecode and JIT-compiled code in an efficient a manner as possible. With that being said, if you think you can pre-optimise your bytecode then it probably won't do much harm. It is worth being aware, however, that JVMs can tend towards performing better (and not crashing) when presented with just the sort of bytecode the Java compiler tends to construct. It is not unknown for optimisations to be missed or even for the JVM to crash when permutations of bytecode occur that are correct but unlike what would be produced by javac. Hopefully that sort of thing is more in the past now, but may be something to be aware of. Obfuscators such as ProGuard will perform many static optimisations on your bytecode for you. The HotSpot compiler will optimize your code at runtime better than is possible at compile-time - it has more information to work with, after all. The only time you should be optimizing the bytecode instead of just your algorithm is when you are targeting mobile devices, such as the Blackberry, where the JVM for that platform is not powerful enough to optimize code at runtime and just executes the bytecode. Note to Aseraphim: It can also be useful to optimise bytecode for non-embedded applications in some limited cases: When delivering code over the wire, eg for WebStart apps, to minimise deliverable/cache size and because you don't necessarily know the capability/speed of the client. For code that you know is performance critical and used at start-up before (say) HotSpot has had time to gather any stats. Again, the transformations that a good optimiser/obfuscator performs can be very helpful.