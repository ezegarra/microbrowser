The Interface Segregation Principle oop design-patterns ISP states that: Clients should not be forced to depend on methods that they do not use. ISP relates to important characteristics - cohesion and coupling. Ideally your components must be highly tailored. It improves code robustness and maintainability. Enforcing ISP gives you following bonuses: High cohesion - better understandability, robustness Low coupling - better maintainability, high resistance to changes If you want to learn more about software design principles, get a copy of Agile Software Development, Principles, Patterns, and Practices book. It simplifies the interface that any one client will use and removes dependencies that they might otherwise develop on parts of the interface that they don't need. There's a nice paper which goes into some depth about this principle here. One reason is that having many interfaces with a minimal amount of methods for each one makes it easier to implement each interface and to implement them correctly. A large interface can be unruly. Also, using a focused interface in a scenario makes the code more maintanable because you can see which facet of the object is being used (e.g., an IComparable interface lets you know that the object is only being used for comparisons in the given scenario). The interface segregation is the â€œIâ€? on the SOLID principle, before digging too deep with the first, letâ€™s explain whatâ€™s does the latter mean. SOLID can be considered a set of best practices and recommendations made by experts (meaning they have been proved before) in order to provide a reliable foundation in how we design applications. These practices strive to make easier to maintain, extend, adapt and scale our applications. Why should I care about SOLID programming? First of all, you have to realize you are not going to be forever where you are. If we use standards and well known architectures, we can be sure that our code will be easy to maintain by other developers that come after us, and Iâ€™m sure you wouldnâ€™t want to deal with the task of fixing a code that didnâ€™t applied any known methodology as it would be very hard to understand it. The interface segregation principle. Know that we know what the SOLID principles are we can get into more detail about the Interface Segregation principle, but what exactly does the interface segregation says? â€œClients should not be forced to implement unnecessary methods which they will not useâ€? This means that sometimes we tend to make interfaces with a lot of methods, which can be good to an extent, however this can easily abused, and we can end up with classes that implement empty or useless methods which of course adds extra code and burden to our apps. Imagine you are declaring a lot of methods in single interface, if you like visual aids a class that is implementing an interface but that is really needing a couple of methods of it would look like this: In the other hand, if you properly apply the interface segregation and split your interface in smaller subsets you can me sure to implement those that are only needed: See! Is way better! Enforcing this principle will allow you to have low coupling which aids to a better maintainability and high resistance to changes. So you can really leverage the usage of interfaces and implementing the methods when you really should. Now letâ€™s review a less abstract example, say you declared an interface called Reportable public interface Reportable {

        void printPDF();
        void printWord();
        void printExcel();
        void printPPT();
        void printHTML();


}
 And you have a client that will only to export some data in Excel format, you can implement the interface, but would you only have to implement the excel method? The answer is no, you will have to code the implementation for all the methods even if you are not going to use them, this can cause a lot of junk code hence making the code hard to maintain.. Remember keep it simple and donâ€™t repeat yourself and you will find that you are already using this principle without knowing. This principle primarily serves twin purposes To make the code more readable and manageable. Promotes single responsibility for classes ( high cohesion ). Ofcourse why should a class have a method that has no behavioural impact ? Why not just remove it. Thats what ISP is about There are few questions that a designer must ask with concerns to ISP What does one achieve with ISP How to I analyse an already existing code for any ISP violations To take this discussion further, I must also add that this principle isn't a 'principle' in the strictest sense, because under certain circumstances, applying ISP to the design, instead of promoting readability, might make the object structure unreadable and cluttered with unnecessary code. You may well observe this in the java.awt.event package More at my blog: http://design-principle-pattern.blogspot.in/2013/12/interface-segregation-principle.html